\section{Data Driven Drawing}

Our goal is provide a drawing interface on mobile device that provides the feeling that the user is in full control, while simultaneously providing assistance, in particular, to overcome the inherent fat finger problem. As described earlier, the problem is more constrained than a general drawing system by using a tracing paradigm. To provide assistance, we take advantage of previous drawings of the same face and then pull the users strokes towards a {\em consensus} of previous drawings when the user's stroke appear to approximate the local consensus.

Our stroke correction strategy has two phases.
\begin{itemize}
\item Consensus Finding: Using the training drawings available for an image, we create a correction vector field, which indicates for each pixel on the image, the delta toward the nearest {\em consensus line}.  This phase is run off-line.
\item Real-time Correction: The correction vector field is transmitted to the mobile device along with the image to be traced.  When a user draws a stroke, the field is sampled along the path of the stroke, and the stroke is moved in such a way to balance stroke style and follow the correction field.
\end{itemize}

\subsubsection{The Correction Vector Field}


A correction vector field, $V(p)$, is constructed to point, for each location in the image, towards the nearest {\em consensus stroke}, which intuitively represents a stroke that appears in many drawings. To compute $V$, we use a modified version of the iterative mode finding in {\em mean shift}~\cite{10.1109/ICCV.1999.790416}.


\begin{figure}
  \centering%
  \includegraphics[width=3.4in]{ellipse.png}
  \caption{  }
  \label{fig:ellipse}
\end{figure}


Given a point $p$ in the image to be drawn, we first find the nearest stroke point, $v_i$ in each drawing, $D_i$, in our training set. We place the nearest points, $v$, in a coordinate system using $p$ as the origin (see the red points in Figure~\ref{fig:ellipse}). One key observation is that the position of the point $v_i$ also encodes the orientation of the nearest stroke in $D_i$. In particular, the stroke orientation will always be orthogonal to the vector $v_i$ (aside from minor discretization noise), otherwise there would be some closer stroke point. Thus, a series of nearest strokes that are closely aligned in position and orientation will produce a set of nearest points, $v$, that lie approximately along a line, and this line will intersect the origin (i.e., the point $p$).

Our goal is find a consensus of nearby strokes that avoids undue influence from outliers. For the points, $v$, we seek a {\em mode} in which the points lie in close proximity to each other and lie roughly along a line pointing back towards the origin. We employ an iterative mean shift style algorithm for the mode finding.

Our algorithm works by iteratively updating a vector of weights, {\bf w}, which represent the belief that a particular neighbor is a member of the consensus stroke. The final correction vector, $V(p)$, is given a weighted mean of the points, $v$. We initialize all weights using a symmetric Gaussian centered at the origin, with $\sigma$ equal to the mean distance to all neighbors $v$.


The iteration proceeds by determining an anisotropic Gaussian with weighted mean, $\mu$ (equation~\ref{mean}),
$\sigma_1$ in the direction back toward the origin, $p$, (equation~\ref{sig1}), and ($\sigma_2$) in the orthogonal direction (equation~\ref{sig2}).
\begin{equation}
{\bf \mu} = \left(\sum_j w_j {\bf v}_j\right) / \sum_j w_j  \label{mean}
\end{equation}
and define the normalized mean,
\begin{equation}
{\bf \nu} = \mu/||\mu||
\end{equation}
with the anisotropic standard deviations given by
\begin{eqnarray}
\sigma_1 =  \sqrt{\left(\sum_j w_j (({\bf v}_j-\mu)^{\bf T}\nu)^2\right) / \sum_j w_j} \label{sig1}\\
\sigma_2 =  \sqrt{\left(\sum_j w_j ({\bf v}_j^{\bf T}\nu_\perp)^2\right) / \sum_j w_j} \label{sig2}
\end{eqnarray}
We then reweight all points according to the new gaussian distribution, including a simple regularization ${\bf w} = {\bf w}/ ({\bf w}+0.05)$.  The regularization serves to reinforce points near the mean, and further discount points away from the mean. The term 0.05 which intuitively says that any points more than two standard deviations away from the mean are mostly noise, was chosen experimentally.

The iterations end when $\mu$ stops moving, and $V(p)$ is set to $\mu$.

\subsubsection{Laplacian Stroke Morphing}


The vector field, $V$, defined above indicates a best guess of how any individual vertex on a stroke polyline should move to match the consensus of all drawings.

The naive approach is to take the points $(p_1, \ldots, p_k)$ comprising a stroke, along with their correction field samples $(V(p_1), \ldots, V(p_k)$, and simply move each point to arrive at $(p_1 + V(p_1), \ldots, p_k + V(p_k))$.  Unfortunately, noise and discontinuities in the vector field cause undesirable end results. More importantly, any {\em stylistic} choices such as intentional wiggles inherent in the original stroke would also be lost. The fat finger problem is likely to cause the input stroke to be off primarily in displacement, however, the overall shape can be more trusted to represent the user's {\em intent}.

Our goal is to use the guidance of the vector field on where to move, but still maintain most of the shape of the original stroke.  We therefore create and solve an over-constrained linear system that represents both of those objectives.  In the following system, $p_i$ represents an input stroke sample locations for $i=1\ldots k$, $V_i$ is a shorthand for $V(p_i)$ representing the correction vector field at $p_i$, and $p_i'$ represents the corrected sample.

The first $k$ equations simply state:
\begin{equation}
p_i' = p_i + V_i
\end{equation}
The final $k-1$ equations try to make the displacement of neighboring points be the same:
\begin{equation}
p_i' - p_{i-1}' = p_i - p_{i-1}
\end{equation}
Or in matrix form, with omitted matrix elements 0:
\[
\left[
\begin{array}{ccccc}
1 &  &  &  & \\
 & 1 &  &  &  \\
 &  & \ddots &   &  \\
 &  &  & 1 &  \\
  &  &  &  & 1 \\
-1 & 1 &   &  &  \\
 & -1 & 1 &  &  \\
 &  & \ddots & \ddots &  \\
 &  &  & -1 & 1 \\
\end{array}
\right]
\left[
\begin{array}{c}
p'_1 \\
p'_2 \\
\vdots \\
p'_{k-1} \\
p'_k
\end{array}
\right]
 \approx
\left[
\begin{array}{c}
p_1 + V_1\\
p_2 + V_2\\
\vdots \\
p_{k-1} + V_{k-1}\\
p_k + V_k\\
p_2-p_1 \\
p_2-p_3 \\
\vdots \\
p_k - p_{k-1}
\end{array}
\right]
\]


We solve this system to minimize the sum-of-square error.
